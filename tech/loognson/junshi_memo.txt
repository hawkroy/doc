整理了一下SS的bus模型
计算总线的响应时间（response_time）和服务时间（service_time）：
•     如果总线类型是RAM总线（SIMPLE_RAMBUS），而且请求类型是读请求（Read_Request），则响应时间和服务时间都是6个总线时钟周期（bus->clock_differential * 6）。
•     如果总线类型是RAM总线（SIMPLE_RAMBUS），而且请求类型是读响应（Read_Response），则响应时间是1个总线时钟周期（bus->clock_differential），而服务时间是1个总线时钟周期加上数据的传播时间（bus->clock_differential * (request_size/bus->width)）。
•     如果总线类型是RAM总线（SIMPLE_RAMBUS），而且请求类型是写请求（Write_Request），则响应时间和服务时间都是6个总线时钟周期加1个总线时钟周期再加数据的传播时间（bus->clock_differential * (6 + 1 + request_size/bus->width)）。这表示响应请求的时间和服务传输传递的时间。
•     如果总线类型不是RAM总线，则响应时间为1个总线时钟周期加仲裁的时间（bus->clock_differential * (bus->arbitration + 1)），而服务时间为仲裁的时间和数据的传播时间（bus->clock_differential * (bus->arbitration + ceil((float)request_size/bus->width))）。 


龙芯2，五个执行单元，两个整形，1个访存，2个浮点。两个浮点不重叠；两个整形只对基础ALU指令重叠。
只有一种情况需要端口分配，分配方式有点奇怪。


SimpleScalar的分支方向预测器

Simplescalar支持五种分支预测器：组合预测器（ BPredComb ），两级预测器 （ BPred2Level ），饱和预测器（ BPred2bit ），静态Taken预测器 （ BPredTaken ）和静态Not-Taken预测器（ BPredNotTaken ）。

条件分支采用分支预测器确定方向。同时，条件分支都需要更新分支预测器。 
饱和预测器。饱和预测器的大小可以配置（ bimod_config ）。每一个单元是一个两 比特饱和计数器。如果饱和计数器数值大于1，则判定预测方向Taken；反之，则判定预 测方向Not-Taken。更新饱和预测器的时候，如果分支Taken，则增加计数器直到3；如 果分支Not-Taken，则减少计数器直到0。访问饱和预测器的地址：

    取指地址右移19位和取指地址右移2比特异或。 
两级预测器。第一级是历史信息寄存器，第二级是饱和计数器表。各级计数器的大小、 历史信息寄存器的宽度等都可以配置（ twolev_config ）。预测时，首先访问历史信 息寄存器，获得历史信息，在将历史信息与分支地址结合起来索引饱和计数器。饱和计 数器的访问与饱和预测器相同。第一级和第二级访问的地址如下：

    访问第一级的索引由取指地址右移2位（一条指令占用4字节）得到，并且根据第一级 的单元数取掩码。
    访问第二级的索引由历史信息和取指地址得到。取指地址右移2位再与历史信息异或。 异或结果对历史信息寄存器宽度取掩码。最终构成第二级的索引，低位由异或结果提 供，宽度就是寄存器的宽度；高位由物理地址提供，只排除低两位。 
分支历史信息记录了这个单元命中的分支的跳转情况。如果分支指令Taken，则在最低 位移入一个1；如果分支指令Not-Taken，则在最低位移入一个0。

组合预测器。组合预测器由一个直接预测器、一个两级预测器和一个元预测器。组合预 测器的配置参数（ comb_config ）。直接预测器是一个饱和预测器，访问和更新方式 与前述相同。两级预测器的访问和更新方法与前述相同。直接预测器和两级预测器都提 供一个结果。最终选择的结果取决于元预测器。元预测器也是一个饱和预测器，访问和 更新方法与前述相同。如果元预测器大于1，则选择两级预测器的结果；反之，则选择 直接预测器的结果。在更新的时候，如果两级预测器的方向是正确的，累加元预测器； 反之，减少元预测器。

动态Taken预测器。分支指令总是Taken的。

静态Not-Taken预测器。分支指令总是Not-Taken。 
SimpleScalar的目标地址预测器

SimpleScalar支持目标地址缓存表（BTB）和返回地址堆栈（RAS）。

BTB采用组相连结构。BTB的组数和路数都可以配置（ btb_config ）。BTB的每个单元 保存分支指令地址、指令操作码和目标地址。

    指令地址就是单元的标签，保存完整分支地址。如果BTB有多路，要求标签一致；反 之，不要求比较标签。
    目标地址也是保存的完整地址。 
BTB的访问索引由取指地址右移2位（一条指令占用4字节）得到，并且根据BTB的组数取 掩码。

BTB单元的分配和更新采用LRU策略，即最早命中（Taken分支）的单元第一个被替换。 只要是Taken的分支都会引起BTB更新。

RAS堆栈的大小也可以配置。Call指令压栈RAS；Return指令出栈RAS。

    使用组合预测器、直接预测器和两级预测器，目标地址来自于BTB和RAS。
    使用静态Taken预测器，目标地址是用参数给定的。
    使用静态Not-Taken预测器，目标地址总是预测器地址。 
需要说明的是，SimpleScalar的分支预测器在使用的时候，应当与译码同时或者完成部 分译码。所以， bpred_lookup 需要单独的参数指定Call和Return指令，以及目标地 址。

龙芯2的预测器 
龙芯2的分支方向预测器是两级预测器。由于这个预测器的第一级只有一个单元，所以 保存了全局的分支历史信息，所以也称为全局历史信息预测器。龙芯2的默认配置是： 第一级全局历史信息，第二级4096单元，历史信息宽度9比特。只有条件跳转指令使用 分支方向预测器，也只有条件跳转指令更新分支方向预测器。

    访问第二级的索引由历史信息和取指地址得到。取指地址右移5位（两个取指单元） 再与历史信息异或。异或结果保留低9位（历史信息寄存器宽度）。最终构成第二级 的索引，低3位由取指地址提供（[4:2]），高9位由异或结果提供，总计12位。

龙芯2提供BTB预测器，用于预测指令的目标地址。龙芯2的默认配置是：1路，128组。

    访问BTB的索引由取指地址右移5位（两个取指单元）得到，使用[11:5]。
    访问标签为BTB的索引右移5+7位。如果是局部标签（PARTIAL_BTB），则只保留6比特。 
龙芯2提供RAS，但是不用于预测。RAS在译码流水级访问，根据已经译码确定的Call指 令和Return指令进行压栈和出栈。

龙芯2的预测器维护 
预测器的访问占用两个周期。在取指流水线，利用取指地址 （ godson2_cpu::fetch_reg_PC ）访问方向预测器和BTB，得到预测的方向和目标地址。 但是并不更新全局历史信息。而是将历史信息备份到指令描述结构体中。参见 fetch_stage 和 bpred_lookup_godson 。

在译码流水线，利用译码得到的指令类型，完成目标地址和方向的判断：

    如果指令是Return指令，访问RAS得到目标地址。跳转方向一定是Taken。
    如果指令是JR或JALR指令，目标地址来自BTB。跳转方向一定是Taken。
    如果指令是条件指令，目标地址来自BTB。跳转方向来自与两级预测器。

在译码流水线，如果指令是条件跳转指令，则需要更新分支历史信息。但是，更新动作 需要延后一个周期才能真正更新。参见 decode_stage 。

在回写流水线，如果分支指令以及这条指令的延迟槽都已经完成，则更新分支预测器。 参见 writeback_stage 和 bpred_update 。如果分支指令预测错误，则需要恢复 流水线的状态（全局历史信息和RAS栈顶指针）。参见 bpred_recover 。  


NoC 
* - 拓扑：2D-mesh拓扑。UP和DOWN改变行y；LEFT和RIGHT改变列x。
 * - 协议控制：分为4个分离的网络，REQ、INVN、WTBK和RESP。cache发起数据请求进入
 *   REQ；INVN传输snoop消息；WTBK传递返回的数据；RESP返回ACK/ACK_DATA。
 * - 数据包大小：2个flit。
 * - 路由器结构：5个端口（HOME，UP，DOWN，LEFT，RIGHT）。输入FIFO。本地端口的
 *   REQ和INVN通道的缓存大小missq；WTBK通道的缓存大小wtbkq；RESP通道的缓存大小
 *   为1。其他通道的缓存大小就是fifo大小。FIFO的实现被完全模拟。
 * - 流水线：接收flit，路由&仲裁，交换&传输。
 * - 路由算法：XY路由，先在同行移动，再在同列移动。在进行仲裁的时候进行本级路由
 *   计算。
 * - 仲裁算法：Round-Robin。顺序为：HOME，UP，DOWN，LEFT到RIGHT。每一次仲裁后会
 *   保留上一次仲裁的结果。下一次仲裁从上一次仲裁的grant之后开始。
 * - 流量控制：credit-base流量控制。如果是本地端口，REQ和INVN端口的credit会同时
 *   更新这两个通道。flit离开路由器时，将本地credit减一；flit离开输入缓存时，前
 *   一级credit加一。
 * - 物理特性：线路延迟为1T。
 * - 软件实现：路由器内部采用倒叙流水线；路由器之间采用事件队列。 

